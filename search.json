[
  {
    "objectID": "debugging/intro.html",
    "href": "debugging/intro.html",
    "title": "Workshop Notes",
    "section": "",
    "text": "Today we’ll talk a bit about debugging your code and take a closer look at Python’s pdb as well as VSCode’s debugger integration.\n\n\nBefore we get into the tools, let’s talk about some techniques for debugging your code.\n\n\nprint statements are particularly useful in interpreted languages like Python. They allow you to see the state of your program at any point in time.\nDownsides:\n\nYou have to add them to your code, run it, and remember to remove them.\nThey can clutter up your code & output, making it harder to read.\nDebugging code in a loop or frequently-called function can be tedious with a ton of print output to sift through.\nYou have to know before running your program what you want to see, if you discover a problem later you have to add more print statements and run it again.\n\n\n\n\nLogging statements are similar to print statements, but they are more flexible and can be turned on and off.\nBy adding logging statements at different levels of severity you can adjust at runtime how much information you want to see. Typical logging levels are: DEBUG, INFO, WARNING, ERROR, and CRITICAL. You can log messages at any of these levels and then set the logging level to control which messages are displayed.\nPython logging documentation.\nThese can help with some of the clutter, but are still not an ideal situation.\n\n\n\nThis technique is named after a story in the book The Pragmatic Programmer by Andrew Hunt and David Thomas. The story goes that a programmer would carry around a rubber duck and explain their code to the duck. Often, in the process of explaining the code, the programmer would realize what was wrong.\nExplaining your code to yourself aloud, or a peer can help identify flaws in your logic.\nThis helps build an important skill & should not be overlooked, but obviously won’t solve all your problems.\n\n\n\nChatGPT can be the rubber duck that talks back. You can use it to explain your code to yourself and see what it thinks you’re saying. If it’s not what you expect, you can use that to help you debug your code.\nYou can of course also show it code snippets and see if it identifies any discrepancies between how you explain your code and how it interprets it. This is a relatively safe way of relying on ChatGPT that leaves you in control of the code that’s written but allows you to benefit from the model’s abilities.\nIt will perform best when given a clear description of what the code “should” do, and any errors you are seeing.\nExample:\nI am trying to write a function that counts the number of times each word appears in a text. I’ve written this function but it is counting letters for some reason instead of words. I try to iterate over each word and add it to a dictionary if it’s not already there, otherwise increment the count.\ndef word_count(text, count_dict={}):\n    for word in text:\n        if word in count_dict:\n            count_dict[word] += 1\n        else:\n            count_dict[word] = 1\nChatGPT’s response:\nThe issue with your function is that when you iterate over the text using a for loop, it iterates over each character in the string, not the words. To fix this, you can use the split() method to convert the text into a list of words before iterating. Here’s an example:\ndef word_count(text, count_dict=None):\n    if count_dict is None:\n        count_dict = {}\n    words = text.split()\n    for word in words:\n        if word in count_dict:\n            count_dict[word] += 1\n        else:\n            count_dict[word] = 1\n    return count_dict\nI also made a small change to the default value of count_dict. Using a mutable object like a dictionary as a default argument value is not recommended, as it can lead to unexpected behavior. Instead, use None as the default value and initialize the dictionary inside the function if it’s not provided.\nPretty great at things like this, but remember to verify the code it writes and watch out for API hallucinations.\n\n\n\n\nThe focus of today is going to be on interactive debugging. This is a technique that allows you to step through your code and see the state of your program at each step. Used properly, this can save you a lot of time and frustration and help you understand your code at a deeper level.\nThe interactive debugger we’ll be using today is called pdb. It’s a command line debugger that comes with Python.\npdb may not be the most user friendly debugger, but it’s very powerful and it’s always available. (Meaning it comes pre-installed and will be useful if you find yourself debugging on a server or other environment where you can’t rely on VSCode.) It’s interface is similar to the gdb debugger (originally for C and C++ programs) which most other debuggers are based on as well.\nTo run pdb against your program, you can use the -m flag to run it as a module.\npython -m pdb my_program.py\nThis will start the debugger and pause execution at the first line of your program. You can then use the following commands to step through your program.\n\n\n\nnext - step to next line (aka step over)\nstep - step into a function call (aka step into)\nreturn - continue until the current function returns (aka step out)\ncontinue - continue until the next breakpoint\nlist - list the current line of code\nprint - print the value of a variable\nquit - quit the debugger\n?/help - show a list of commands\n\n\n\n$ python -m pdb debugging/example1.py\n\n\n\n\nYou can set a breakpoint in your code by adding the following line:\nbreakpoint()\n(Older code may use import pdb; pdb.set_trace() instead.)\nThis will pause execution at that point and allow you to step through your code.\n\n\n\n\n\n\nVSCode has a built in debugger that can be used to step through your code. It’s a bit more user friendly than pdb and it’s integrated into the editor.\nTo use it, you’ll need to add a launch.json file to your project. This file tells VSCode how to run your program and what to do when you start debugging.\nYou can create a launch.json file by clicking on the debug icon in the sidebar and then clicking the gear icon to create a new launch configuration.\n\n\n\nCreate launch.json\n\n\nThis will create a launch.json file in your .vscode directory. You can then edit this file to configure your debugger.\nHere’s an example launch.json file:\n{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"Python: Current File\",   // this is the name that will show up in the dropdown\n            \"type\": \"python\",\n            \"request\": \"launch\",\n            \"program\": \"${file}\",             // this tells VSCode to run the current file\n            \"arguments\": [\"arg1\", \"arg2\"],    // if your program requires arguments you'll need to add this\n            \"console\": \"integratedTerminal\",\n            \"justMyCode\": true                  // this tells VSCode to not step into external libraries\n        }\n    ]\n}"
  },
  {
    "objectID": "intermediate-python.html",
    "href": "intermediate-python.html",
    "title": "Workshop Notes",
    "section": "",
    "text": "Today we’re going to be talking about some features of Python that might be considered “ergonomic.”\nYou can, and have, gotten by without using these as they aren’t fundamental in the way that loops, functions, and classes are.\nLearning these features gives you additional ways to solve problems, which can be more efficient or elegant than alternatives.\nSome topics that fall into this category are:\n\nComprehensions (which you’ve already seen)\nDecorators (which you’ve seen a little bit of)\nExceptions & Context Managers\nGenerators\nType Hints\n\n\n\n\n\nNo matter how good your code is, there’s always going to be a chance that something goes wrong.\nA common example is a file not being available when you try to open it. (Perhaps it is missing or you don’t have permission to access it.)\nYou could imagine code like this:\nfile = open(\"file.txt\")\nfile.write(\"Hello, world!\\n\")\nfile.write(\"Second Write\")\nfile.close()\nIf you’re worried about open failing you might end up with code like this:\nfile = open(\"file.txt\")\n# check if file is open (not a real method, just an example)\nif file.is_open():\n    file.write(\"Hello, world!\\n\")\n    file.write(\"Second Write\")\n    file.close()\nBut what if other methods fail? If we’re writing over a network, the disk is full, or the file is locked by another process?\n# this code does not work, demo purposes\nfile = open(\"file.txt\")\nif file.is_open():\n    success = file.write(\"Hello, world!\\n\")\n    if success:\n        success = file.write(\"Second Write\")\n\n    if not success:\n        # handle error\n\n    # close file no matter what\n    file.close()\nThis can get very messy very quickly.\n\n\n\nIn Python, we can use exceptions as an alternate control flow path. What this means is that instead of executing code sequentially, we can jump to a different part of the program if an exception is raised.\nThe two key pieces of syntax are raise, and try-except.\n\n\nWhen a raise statement is encountered, typical execution is stopped and the program jumps to the nearest matching except block.\nraise ExceptionType(\"message\")\nAn exception can be any class that inherits from BaseException, common built in exceptions are:\n\nException\nValueError\nTypeError\nKeyError\nIndexError\nFileNotFoundError\nNotImplementedError\n\nYou can also create your own by subclassing Exception or any other relevant type.\nclass TooManyTokens(Exception):\n    pass\n\n...\n\nif len(tokens) > MAX_TOKENS:\n    raise TooManyTokens(f\"Expected at most {MAX_TOKENS} tokens, got {len(tokens)}\")\n\n\n\ntry:\n    # code that might raise an exception\nexcept ExceptionType:\n    # code to run if an exception is raised\nexcept OtherExceptionType as e:\n    # code to run if an exception is raised\n    # in this example, e will be the exception object so you can\n    # use it/log it/etc.\nelse:\n    # code to run if no exception is raised\nfinally:\n    # code to run no matter what\n\nonly one except block will be run, the first one that matches the exception type\nan except block can match multiple exception types by providing a tuple of types or by using a base class\nelse and finally are not required and often omitted, but can be useful.\n\nOur file handling example can be rewritten to use exceptions:\ntry:\n    file = open(\"file.txt\")\n    file.write(\"Hello, world!\\n\")\n    file.write(\"Second Write\")\nexcept (OSError, IOError) as e:\n    # handle error\nfinally:\n    file.close()\nNow if any of these three lines raise an exception, the file will still be closed.\n\n\n\n\nContext managers are a way to automatically run some code when entering and exiting a block of code.\nThey are commonly used to manage resources like files, locks, and database connections and can be thought of as related to exceptions in that they provide an alternate way to work with errors.\nIf a Python object has __enter__ and __exit__ methods, it can be used as a context manager.\nRewriting our file handling example to use a context manager:\n__enter__ is called when entering the with block, and __exit__ is called when exiting the block.\nThese are called no matter what, so if an exception is raised, __exit__ will still be called.\nIf you have no custom code you need to run, just want to make sure something is closed, you could rewrite the above example as\nwith open(\"file.txt\") as file:\n    file.write(\"Hello, world!\\n\")\n    file.write(\"Second Write\")\nAny exception raised in the with block will be caught and passed to __exit__. file's __exit__ method will then close the file.\nOther common uses of context managers are:\n\nwith db_connection: - Ensures database connection is closed when the block exits.\nwith db.transaction.atomic(): - Ensure that a block of code is run within a database transaction so changes can be rolled back if an exception is raised.\n\n\n\n\nAs mentioned, if a Python object has __enter__ and __exit__ methods, it can be used as a context manager.\nYou can write your own context managers by implementing these methods.\n\nclass MyContextManager:\n    def __enter__(self):\n        print(\"entering block\")\n        # code to run when entering the block\n\n        # return value is assigned to the variable in the `as` clause\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        # code to run when exiting the block\n        # exc_type, exc_value, and traceback are the exception info\n        # if an exception was raised, otherwise they are None\n        if exc_type is not None:\n            print(\"exception was raised\")\n        else:\n            print(\"exiting normally\")\n\n        # return True to suppress the exception propagating\n        return True\n\n\nwith MyContextManager() as context:\n    print(\"inside block\")\n\nentering block\ninside block\nexiting normally\n\n\n\nwith MyContextManager() as context:\n    7 / 0\n\nentering block\nexception was raised\n\n\n\n\n\n\nTry to keep your try blocks as small as possible, only including the code that might raise an exception.\nCatch the most specific exception possible, and only catch exceptions that you can handle.\nAvoid catching Exception, or omitting the exception type entirely. This will catch all exceptions, which can lead to hard-to-find bugs.\nPython Docs - Errors and Exceptions\nPython Docs - Context Managers\nPython Docs - with Statement\n\n\n\n\n\nGenerators are a special type of function that can be re-entered.\nAn incredibly powerful tool for writing efficient code, especially when dealing with large amounts of data.\n\n\nRecall that Python objects use dunder methods to implement most of their functionality.\nYou may recall that when implementing a class you can define __getitem__ and __setitem__ to make your class subscriptable.\n\nll = [1, 2, 3]\nprint(ll[0])\nprint(ll.__getitem__(0))  # you wouldn't write this, but it's the same thing\n\nll[0] = 4\nll.__setitem__(0, 4)  # you wouldn't write this, but it's the same thing\n\n1\n1\n\n\nA for loop is similarly syntactic sugar for calling two other methods: __iter__ and __next__.\n\nll = [1, 2, 3, 4]\nfor item in ll:\n    print(item)\n\n1\n2\n3\n4\n\n\n\nll = [1, 2, 3, 4]\niterator = ll.__iter__()\nwhile True:\n    try:\n        item = iterator.__next__()\n    except StopIteration:\n        break\n    print(item)\n\n1\n2\n3\n4\n\n\n\n__iter__ returns an iterator object, a special intermediary object that tracks the current position in the iterable.\n__next__ returns the next item in the iterable, and raises StopIteration when there are no more items.\n\nYou could write your own classes that implement these methods to make them iterable. But today we’ll look at another way to make iterables: generators.\n\n\n\nLet’s say that you want to write a function that will return many values, but you only intend for one to be used at a time.\n\ndef permute(word):\n    if len(word) == 1:\n        return [word]\n    else:\n        result = []\n        for i in range(len(word)):\n            for perm in permute(word[:i] + word[i + 1 :]):\n                result.append(word[i] + perm)\n        return result\n\n\npermute(\"abc\")\n\n['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n\n\nGreat, but the size of the returned list will be \\(n!\\), where \\(n\\) is the length of the string.\nIt’s also possible we’re searching for a particular permutation, so we won’t actually need all of the results & it’d be nice to stop early.\n\nresults = permute(\"too long\")\nprint(len(results))\n\n40320\n\n\n\n\n\nOften, we only need one item at a time, and we don’t want to store all of the results in memory.\nThis is the case with a lot of data processing tasks, where we might have millions of records, but only need to process one at a time.\nGenerators are special functions that return an iterator.\nLet’s take a look at range:\n\ndef stop_cond(x):\n    # contrived stop condition, perhaps you're searching for a value that fits some criteria:w\n    return x == 17\n\n\nfor x in range(10_000_000):\n    print(x)\n    # we don't actually need all of the values\n    if stop_cond(x):\n        print(\"found it!\")\n        break\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nfound it!\n\n\nIf range returned a list, it would need to allocate a large list, which is both slower and more memory intensive.\nInstead range’s implementation looks something like this:\n\n# simplified form with one parameter\ndef range(n):\n    i = 0\n    while i < n:\n        yield i\n        i += 1\n\nyield is a special keyword that returns a value from the function, but doesn’t exit the function the way return does.\nWhen the function is called again, it will continue from where it left off.\nLet’s rewrite permute as a generator:\n\ndef ipermute(word):\n    if len(word) == 1:\n        yield word\n    else:\n        for i in range(len(word)):\n            for perm in permute(word[:i] + word[i + 1 :]):\n                yield word[i] + perm\n\n\nfor perm in ipermute(\"abc\"):\n    print(perm)\n\nabc\nacb\nbac\nbca\ncab\ncba\n\n\n\n\n\nYou can use generator expressions to create generators without having to write a function.\n\nsquares = (x**2 for x in range(1000000))\n\nThis looks like a list comprehension, but has parentheses instead of brackets.\nIt creates a generator that will return the squares of the numbers from 0 to 999999.\n\n\n\nThe itertools module contains many useful functions for working with iterators, all of which are implemented as generators.\nUseful functions include:\n\nitertools.permutations - permutations of an iterable\nitertools.combinations - combinations without replacement\nitertools.product - cartesian product of multiple iterables (like nested for loops)\nitertools.chain - concatenate iterators\nitertools.islice - slice an iterator the way you would a list\nitertools.groupby - group items by a key\nitertools.tee - create multiple iterators from one\n\n\n\n\n\nThe biggest change to Python in recent years is the addition of type annotations.\n\n\nPython is a dynamically typed language, which means that the type of a variable is determined at runtime.\nIt also means the type can change:\nx = 1\nx = \"hello\"  # no error\nThis is a common source of bugs, since it can be difficult to keep track of what type a variable is.\nx = f() # f used to return an int, but now returns a string\n\n\n\nMany languages require variable definitions and function signatures to include type annotations.\n// C\nint f(int x) {\n    return x + 1;\n}\n// Rust\nfn f(x: i32) -> i32 {\n    x + 1\n}\nThis is called static typing, because the type is checked at compile time.\n\n\n\nPython 3.5 introduced type annotations, which are optional type hints that can be added to your code. Evey version of Python since 3.5 has added new features to the type system, but as of 3.10 many of the rough edges have been smoothed out.\ndef f(x: int) -> int:\n    return x + 1\nTwo new pieces of syntax:\n\nAfter a variable definition (typically a function parameter) you can add a colon and the type.\nReturn type annotations can be placed after the closing parenthesis of the function signature with the -> int syntax.\n\n\n\n\nYou can annotate with any of the built-in types:\n\nint\nfloat\nstr\nbool\nNone\netc.\n\nThe compound types (features added in Python 3.7-3.9):\n\nlist\ndict\nset\ntuple\n\nThese allow for annotating the type of the elements in the container:\ndef f(x: list[int]) -> dict[str, int]:\n    return {str(i): i for i in x}\n\nlist[int] - a list of ints\ndict[str, int] - a dictionary with str keys and int values\ntuple[int, str] - a 2-tuple with an int and a str\nset[tuple[int, int, int]] - set of 3-tuples of ints\n\nAnd finally, there are a lot of helper types in the typing module:\n\ntyping.Any - any type\ntyping.Optional[int] - an int or None\ntyping.Union[int, str] - an int or a str\ntyping.Callable[[int, str], bool] - a function that takes an int and a str and returns a bool\n\nYou can also union types together with | (as of Python 3.10):\ndef f(x: int | str) -> int | str:\n    return x\nThis also works as an alternate syntax for Optional:\ndef f(x: int | None) -> int | None:\n    return x\n\n\n\nOne thing to be aware of: these don’t do anything! They’re just hints for the programmer.\n# bad type annotations\ndef f(x: list) -> str:\n    return {\"a\": 1}\n\nf(27.5) \nEvery type annotation is wrong in the above example, but Python will not complain at “compile” time nor at runtime.\nIf you want to check your types, you can use a tool like mypy:\nhttps://mypy-lang.org/\nRunning mypy on the above code will give you output like:\n$ mypy test.py\ntest.py:3: error: Incompatible return value type (got \"Dict[str, int]\", expected \"str\")\ntest.py:5: error: Argument 1 to \"f\" has incompatible type \"float\"; expected \"list\"\nFound 2 errors in 1 file (checked 1 source file)\n\n\n\nSome libraries, such as the built in dataclasses module, pydantic, FastAPI, and typer are starting to use type annotations for runtime type checking.\n\nfrom pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: str\n\n# these are type-checked\nuser = User(id=1, name=\"Sarah Connor\", email=\"sarah@hotmail.com\")\n\n\ntry:\n    # note: id will be coerced to string since types are compatible\n    user = User(id=1, name=\"Sarah Connor\", email=None)\nexcept Exception as e:\n    print(e)\n\n1 validation error for User\nemail\n  none is not an allowed value (type=type_error.none.not_allowed)\n\n\nThis allows you to catch errors earlier, and can result in less boilerplate code.\n\n\n\nYou’ll definitely encounter type annotations in library documentation, and in more modern codebases.\nNorms around their usage are evolving, but it’s worth getting into the habit of using them. It can make your code more clear and easier to maintain. It can help you find bugs before they happen or more easily reason about expected behavior in an unfamiliar codebase.\nMore on typing: https://docs.python.org/3/library/typing.html\nIf you’re using VSCode’s Python extension, it integrates nicely with type extensions and can be configured to warn you about type errors and optionally run tools like mypy to check your types.\n\n\n\n\nA common symptom of the “intermediate” stage of knowing a language is that people tend to overuse features that are available to them.\nPlease keep in mind that there’s nothing inherently better about choosing these over the alternatives, strive to make your code readable and maintainable above all else.\n\n\n\nFunctional Programming - decorators, functools\nMetaclasses\nAsync I/O - asyncio, async/await\nBridging Python to other languages - C API, Cython, CFFI, PyO3\n\n\n\n\nI’ll be sending out some setup instructions in advance, since I’d like the next talk to be more interactive."
  },
  {
    "objectID": "intermediate-git.html",
    "href": "intermediate-git.html",
    "title": "Workshop Notes",
    "section": "",
    "text": "Key Topics:\n\nUsing Git Solo\nGit’s Data Model\nGit Branching\nGit Merging\nUsing GitHub as a Team\n\n\n\nThere are two ways to initialize a Git repository: locally via git init, or by creating a repo on GitHub and cloning it.\n\n\nFrom within a directory that you want to treat as a repo:\nintermediate-git/$ git init\nInitialized empty Git repository in /Users/james/repos/intermediate-git/.git/\nThat’s all it takes. The current directory you’re in is now a git repository with 0 commits.\nIt’s a good idea to create a .gitignore file at this point:\n\n\n\nIf you create your project via GitHub it’ll create a .gitignore file for you. Otherwise, you’d create one yourself.\nThis file should be a list of files/patterns that you’d like to exclude.\nFor example:\n*.pyc\n.vscode\nscraped_data/\n.DS_Store\nThis would avoid checking in .pyc files, your local .vscode settings, and the scraped_data directory. MacOS makes .DS_Store files that you probably don’t want to check in either.\n\n\n\nIf you want to push your repo to GitHub, you’ll need to add a remote:\n$ git remote add origin git@github.com:jamesturk/git-workshop-example.git\n\n\n\nGitHub can provide reasonable defaults based on the language of your project as well, but don’t feel like you need everything that they add, a lot of the files in their list are from editors/IDEs you aren’t using.\n\n\n\n\nGit is what we call a leaky abstraction. This means that it is sometimes necessary to understand how it works under the hood in order to use it effectively.\nIf you read about Git or use some of the more advanced features you’ll eventually see references to some key data structures:\n\nBlobs\nTrees\nCommits\nTags\n\nBlobs are essentially the contents of a file at a given point in time. Trees are a collection of blobs in a directory-like hierarchy. We don’t need to worry about these too much for what we’re talking about today but I wanted to mention them.\nWe do want to talk about commits however.\nYou’re familiar with making commits, but let’s talk a bit more about what is actually stored:\n\nCommit ID (a SHA-1 Hash)\nAuthor information (name, email)\nCommitter information (name, email) [can be different from author, we won’t worry about this]\nCommit message\nTimestamp\nA reference to the tree at the time of the commit.\nParent(s) (zero or more)\n\n\n\n\n\ngraph BT;\n\n    A --> B;\n    B --> C;\n    C --> D;\n    C --> E;\n    A --> W;\n    W --> F;\n    D --> F;\n    E --> F;\n\n\n\n\n\n\n\n\n(I’ll draw git diagrams with the root at the bottom and the most recent commit at the top, which is what you’ll usually see by convention.)\nCommits form a Directed Acyclic Graph (DAG).\nA is a root commit, because it has no parent.\n(Typically repos only have one root commit.)\nF is a merge commit, because it has more than one parent.\n\n\n\nThe simplest Git repo would be one with a purely linear history:\n\n\n\n\ngraph BT;\n\n    A(initialize) --> B(add feature #1);\n    B --> C(add feature #2);\n    C --> D(add feature #3);\n\n\n\n\n\n\n\n\nBut let’s say that we were considering an alternate way to implement our next feature. We might instead create a new branch:\ngit branch new-feature\nAll that this has done is create a new pointer to the same commit that main was already pointing to.\n$ git log\ncommit 8ea904f (HEAD -> main, new-feature)\nAuthor: James\nDate:   Thu Apr 6 17:51:20 2023 -0500\n\n    second commit\n\ncommit 908ee8c\nAuthor: James\nDate:   Thu Apr 6 17:48:12 2023 -0500\n\n    first commit\n\n\n\n\ngraph BT;\n\n    A(first commit) --> B(second commit : main, new-feature);\n\n\n\n\n\n\n\n\nBoth main and new-feature are pointing to the same commit.\nThis is a key concept in Git: branches are mutable labels that point to commits.\nSo here’s what happens when we make a new commit:\n$ ...\n$ git commit -m \"third commit\"\n...\n$ git log\n  commit 1337c4a (HEAD -> main)\n  Author: James\n  Date:   Thu Apr 6 17:52:04 2023\n\n      third commit\n\n  commit 8ea904f (new-feature)\n  Author: James\n  Date:   Thu Apr 6 17:51:20 2023\n\n      second commit\n\n  commit 908ee8c\n  Author: James\n  Date:   Thu Apr 6 17:48:12 2023\n\n      first commit\n\n\n\n\ngraph BT;\n\n    B --> C(third commit: main);\n    A(first commit) --> B(second commit : new-feature);\n\n\n\n\n\n\n\n\nNotice that main moved forward, but new-feature was left behind.\nWhenever you git commit, the branch that you’re currently on will move forward to point to the new commit.\nTo actually use new-feature, we need to switch to it:\n$ git switch new-feature\nNow commits will move new-feature forward. So typically the workflow for starting a new branch looks like:\ngit branch new-branch\ngit switch new-branch\n\n\nYou will also see people use git checkout -b to create a new branch and switch to it in one step.\ngit checkout -b new-branch\n# same as\ngit branch new-branch\ngit checkout new-branch\ngit checkout is an older command, and can do a lot of different things. Feel free to use it, but I prefer to use the newer commands because they are less overloaded with unrelated behavior.\nFinally, git branch without a branch name will list all of the branches in your repo.\n$ git branch\n  main\n* new-feature\n  pr/11\n  pr/12\n  experiments\n\n\n\n\nBranches are (mutable) labels that point to (immutable) commits.\ngit commit moves the branch that you’re currently on forward.\ngit switch changes which branch you’re currently on.\ngit branch <branchname> creates a new branch.\ngit branch without a branch name will list all of the branches in your repo.\n\n\n\n\n\nNow that we can create branches, we can work on multiple features at once. Whether we’re working alone or on a large team, we’ll eventually want to combine our work.\n\n\n\n\ngraph BT;\n\n    A(initial commit : main)\n    A --> B(wireframe UI);\n    B --> C(add bootstrap CSS: ui);\n    C --> D(add profile page: profile-page);\n    C --> E(add login page);\n    E --> F(fix login page bug: login-page)\n    A --> W(backend prototype, very slow : backend);\n    W --> X(add benchmarks);\n    X --> Y1(optimized via rpython : try-pypy);\n    X --> Y2(wrote C version: try-c);\n    X --> Y3(rewritten in Rust: try-rust);\n\n\n\n\n\n\n\n\nWe have a lot of different branches here:\n\nmain\n\nui\n\nprofile-page\nlogin-page\n\nbackend\n\ntry-pypy\ntry-c\ntry-rust\n\n\n\nTypically, we’ll see branches merge back to their parent, so we can consider the ui and backend branches separately. Let’s look at UI for now:\n\n\n\n\ngraph BT;\n\n    A(initial commit : main)\n    A --> B(wireframe UI);\n    B --> C(add bootstrap CSS: ui);\n    C --> D(add profile page: profile-page);\n    C --> E(add login page);\n    E --> F(fix login page bug: login-page)\n\n\n\n\n\n\n\n\n\n\nLet’s say that we’ve finished the login page, and we want to merge it back into ui.\nWe can do that with git merge:\nWhenever we’re modifying a branch, we want to switch to it first. So just as we do before a git commit, we switch to the destination ui branch.\nThen we run git merge login-page.\ngit switch ui\ngit merge login-page\nUpdating e6512d6..d45dee9\nFast-forward\n README.md | 3 ++-\n ...\nYou’ll see in this example, Git did a “fast-forward” merge. This means that Git was able to move the ui branch forward to the same commit that login-page was already pointing to.\nThis was possible because no new commits were created on ui since we created login-page.\nOur updated commit graph:\n\n\n\n\ngraph BT;\n\n    A(initial commit : main)\n    A --> B(wireframe UI);\n    B --> C(add bootstrap CSS);\n    C --> D(add profile page: profile-page);\n    C --> E(add login page);\n    E --> F(fix login page bug: login-page, ui)\n\n\n\n\n\n\n\n\n(The UI label has moved forward to point to the same commit as login-page.)\n\n\n\nAt this point, we’d likely delete the login-page branch, since it’s no longer needed.\ngit branch -d login-page\nAll that this command does is delete the label, the underlying commits will never be deleted.\nIf you try to delete a branch that isn’t yet merged, Git will warn you and prevent you from doing this. If you want to do it anyway, you can use git branch -D.\n(Deleting a branch with unmerged commits makes those commits harder to find, but still doesn’t actually remove the commits.)\n\n\n\nLet’s continue, and say that it is now time to merge in the profile page.\ngit switch ui\ngit merge profile-page\nLet’s say profile-page only touched the profile.html file, and login-page only touched login.html. In this case, Git will be able to automatically merge the two branches together.\nAuto-merging profile.html\nMerge made by the 'recursive' strategy.\n profile.html | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\nGit will automatically create a new commit with two parents, one for each branch.\n\n\n\n\ngraph BT;\n\n    A(initial commit : main)\n    A --> B(wireframe UI);\n    B --> C(add bootstrap CSS);\n    C --> D(add profile page: profile-page);\n    C --> E(add login page);\n    E --> F(fix login page bug)\n    F --> G(merge commit: ui)\n    D --> G\n\n\n\n\n\n\n\n\n\n\n\nBut things aren’t always so clean of course, maybe both branches also modified a base_template.html file instead. In this case, Git will be unable to automatically merge the two branches together.\nAuto-merging base_template.html\nCONFLICT (content): Merge conflict in base_template.html\nAutomatic merge failed; fix conflicts and then commit the result.\nAt this point, your repository will be in a “merge conflict” state. Git will have modified the file to show you the conflicts, in this case two different CSS files were added to the HTML:\n<title>My Website</title>\n<head>\n<<< HEAD\n<link rel=\"stylesheet\" href=\"css/login.css\">\n=======\n<link rel=\"stylesheet\" href=\"css/profile.css\">\n>>> profile-page\n</head>\n<body>\nThe <<< HEAD and >>> profile-page lines show you the two different versions of the file split by ======.\nThe portion between <<< HEAD and ==== is the version of the file that was on the current branch, in this case ui.\nThe portion between ==== and >>> profile-page is the version of the file that was on the branch we’re merging in, in this case profile-page.\nWe probably want both of these lines, so we’ll edit the file to look like this:\n<title>My Website</title>\n<head>\n<link rel=\"stylesheet\" href=\"css/login.css\">\n<link rel=\"stylesheet\" href=\"css/profile.css\">\n</head>\n<body>\nWhen we’ve made these changes, we add and commit our changes just like we usually would. The commit that we create from this state will have two parents, just like we saw above.\n\n\nSometimes you attempt a merge and discover the conflict will be hard to resolve.\nIn this case, you can abort the merge with git merge --abort.\nThis will rewind your repository to the state it was in before you tried to merge, so you can consider other approaches.\n\n\n\nOf course, this is a trivial example, and in a real merge conflict it can be necessary to figure out how the changed lines should be combined.\nIf you’re using VS Code or another editor with Git integration, you can use the editor to resolve the conflict. Otherwise, you’ll need to edit the file manually.\nAlso, note that merge conflicts only occur when the same section of a file was edited in both branches.\nIf the edit is in completely different parts of the file, git will merge them automatically by default. That doesn’t mean that the code works, as you may find that a change to a function in a different file (or part of the same file) changes how the code works.\nThis is another reason that tests are so important, as running the tests after a merge can provide some peace of mind that the code still works as expected if your test suite is comprehensive.\n\n\n\n\n\nSo far, we’ve been working with branches that only exist on our local machine. To share branches with other developers, we need to push them to a remote repository.\n\n\nTo work with remote branches, you’ll need a remote set up, which we saw in Part 1. (If you created/cloned the repo from GitHub a remote already exists).\nTo push a branch to GitHub:\ngit push origin ui   # push the ui branch to the origin remote\nIf you’d like to be able to just type git push to push the current branch, you can set up a default remote branch:\ngit push -u origin ui   # push the ui branch to the origin remote, and set it as the default\nFrom then on, you can just type git push to push the ui branch to the remote.\n\n\n\nIf you want to pull a remote branch that exists on the remote but not locally (e.g. to check out a teammates work), you can use git fetch:\ngit fetch origin login-page   # fetch the login-page branch from the origin remote\nThis will create a local branch called origin/login-page that you can check out & work with as usual.\nIf your intent is to merge all of the changes from the remote branch into your current branch, you can use git pull:\ngit pull origin login-page   # fetch the login-page branch from the origin remote, and merge it into the current branch\n\n\n\nIf you want to delete a remote branch, you can use git push with the --delete flag:\ngit push origin --delete login-page   # delete the login-page branch from the origin remote\n(You can also do this from GitHub’s web interface, which is handy if you’re using Pull Requests.)\n\n\n\n\nSo now that you know how to work with branches, how do you use them in a team?\nThere’s no one right answer, and most teams have adopted a branching strategy that works for them. If you’re joining an existing project or team, follow their lead.\nIf you’re working on a team project, or trying to introduce some order to your own projects, here are some common strategies:\n\n\nThis is the simplest strategy, and can be used for small projects or working independently.\nOne single branch (e.g. main) is used for all development. All commits are made directly to this branch.\n\n\n\nA model that works well for solo work or small to mid-sized teams is the “GitHub Flow” model.\nhttps://docs.github.com/en/get-started/quickstart/github-flow\nIn this model, there is only one long-lived branch, usually called main. (You will also see master used, as it was the default until a few years ago.)\nAll work is done on feature branches, which are merged into main when they are ready.\nThis means, you never commit directly to main, the only commits on main are merges from feature branches.\nGeneral workflow:\n\nCreate a feature branch aimed at tackling a specific problem\nMake commits on the feature branch as needed\nWhen the feature is ready, open a pull request. This lets the team review the code and discuss it.\nOnce the pull request is approved, merge it into main.\nDelete the feature branch.\n\n\n\n\nSimilar to GitHub flow, but with two long-lived branches, main and develop.\nAll work is done on feature branches, which are merged into develop when they are ready.\nWhen develop is ready to be released, it is merged into main.\nThis means develop repeatedly gets merges from main, and main only gets merges from develop.\n\n\n\nOriginal Git Flow Diagram\n\n\n\n\n\nIn our earlier example we branched off of the ui branch to create the profile-page branch.\nThis is a pattern that emerges when teams are sharing a single repository, but working on completely different features.\nIn general, the longer a branch lives the harder it becomes to merge back to main. A strategy like the one used to demonstrate some of the features should only be used if the long-lived branches are very unlikely to conflict, and even then integration can become difficult.\n\n\n\n\n\n\n\nMerge - Creates a merge commit.\nSquash and Merge - Combines all branch commits into one, and creates a merge commit. (Lets you commit as many times as you want on feature branch, and then combine them into one commit on main.)\nRebase and Merge - Rewrites the history of the feature branch to be based on the current state of main, and then creates a merge commit.\n\nhttps://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/about-pull-request-merges\n\n\n\n\nGit Book Chapter 3 https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell\n\n\nRebasing is another way to combine two branches together. Since we only had an hour today I didn’t get into it, but some teams swear by it.\nInstead of creating a merge commit, a rebase will take the commits from one branch and replay them on top of the other branch.\nThis allows you to keep a linear history, but is riskier than merging since it essentially rewrites history so it is possible to lose commits and known working states.\nWe saw that when merging, Git will create a new commit with two parents, one for each branch.\nSome people prefer to keep their commit history linear, and avoid merge commits.\nIn a rebase, Git will take the commits from one branch and replay them on top of the other branch.\n\n\n\nA good commit message should:\n\nHave a first line that is a summary of the change (<50 characters)\nHave a blank line after the summary\nHave a more detailed description of the change as needed\nBe written in the imperative (e.g. “Add” instead of “Added”)\nExplain why the change was made, not what the change was (since that will be in the diff)\n\n\n\n\n\nMention an issue in a commit message and it’ll be linked. (e.g. “Fixes #123” will close that issue when the commit is merged to main.)\nGitHub CLI - Command line interface for GitHub, lets you do things like create and review pull requests from the command line.\n\n\n\n\nTags are a way to mark a specific commit as important. A common use is to tag releases. (e.g. v0.6.2 or 2023-04-05)\nTags are distinct from branches in that they do not move when new commits are added, but are similar in that they are just a pointer to a commit.\nhttps://git-scm.com/book/en/v2/Git-Basics-Tagging\n\n\n\n\nApril 21st"
  }
]